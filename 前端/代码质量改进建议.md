# 前端代码质量和可维护性改进建议

## 路由管理优化

### 1. 路由常量化管理
创建路由常量文件，避免硬编码路径：

```javascript
// src/constants/routes.js
export const ROUTES = {
  HOME: '/home',
  PROFILE: '/profile',
  MY_PRODUCTS: '/my-products',
  MY_ORDERS: '/my-orders',
  MY_FAVORITES: '/my-favorites',
  PUBLISH_PRODUCT: '/publish',
  PRODUCT_DETAIL: (id) => `/product/${id}`,
  ORDER_DETAIL: (id) => `/order/${id}`,
  MESSAGES: '/messages',
  VERIFICATION: '/verification',
  
  // 认证相关
  AUTH: {
    LOGIN: '/auth/login',
    REGISTER: '/auth/register'
  },
  
  // 管理员相关
  ADMIN: {
    DASHBOARD: '/admin/dashboard',
    USERS: '/admin/users',
    PRODUCTS: '/admin/products',
    ORDERS: '/admin/orders',
    CATEGORIES: '/admin/categories',
    ANNOUNCEMENTS: '/admin/announcements',
    AUDIT: '/admin/audit',
    LOGS: '/admin/logs'
  }
}
```

使用示例：
```javascript
// 在组件中使用
import { ROUTES } from '@/constants/routes'

// 替换硬编码
// router.push('/my-products') // ❌ 硬编码
router.push(ROUTES.MY_PRODUCTS) // ✅ 使用常量
```

### 2. 路由导航守卫增强
```javascript
// src/router/guards.js
import { useUserStore } from '@/stores/user'
import { ElMessage } from 'element-plus'

export function setupRouterGuards(router) {
  // 全局前置守卫
  router.beforeEach(async (to, from, next) => {
    const userStore = useUserStore()
    
    // 设置页面标题
    if (to.meta.title) {
      document.title = `${to.meta.title} - 校园二手交易平台`
    }
    
    // 检查认证状态
    if (to.meta.requiresAuth && !userStore.isLoggedIn) {
      ElMessage.warning('请先登录')
      next({ path: '/auth/login', query: { redirect: to.fullPath } })
      return
    }
    
    // 检查管理员权限
    if (to.meta.requiresAdmin && !userStore.isAdmin) {
      ElMessage.error('权限不足')
      next('/home')
      return
    }
    
    // 检查学生认证状态
    if (to.meta.requiresVerification && !userStore.isVerified) {
      ElMessage.warning('请先完成学生认证')
      next('/verification')
      return
    }
    
    next()
  })
  
  // 全局后置钩子
  router.afterEach((to, from) => {
    // 页面访问统计
    if (process.env.NODE_ENV === 'production') {
      // 发送页面访问统计
      analytics.track('page_view', {
        path: to.path,
        title: to.meta.title
      })
    }
  })
}
```

## 组件架构优化

### 1. 组件拆分和复用
```javascript
// src/components/common/ProductCard.vue
<template>
  <div class="product-card" @click="handleClick">
    <div class="product-image">
      <el-image 
        :src="product.coverImage" 
        :alt="product.title"
        fit="cover"
        lazy
      >
        <template #error>
          <div class="image-error">
            <el-icon><Picture /></el-icon>
          </div>
        </template>
      </el-image>
      
      <!-- 商品状态标签 -->
      <div class="status-tags">
        <el-tag v-if="product.isTop" type="danger" size="small">置顶</el-tag>
        <el-tag v-if="product.isRecommend" type="warning" size="small">推荐</el-tag>
      </div>
    </div>
    
    <div class="product-info">
      <h3 class="product-title">{{ product.title }}</h3>
      <p class="product-price">
        <span class="current-price">¥{{ product.price }}</span>
        <span v-if="product.originalPrice > product.price" class="original-price">
          ¥{{ product.originalPrice }}
        </span>
      </p>
      <div class="product-meta">
        <span class="seller">{{ product.seller?.username }}</span>
        <span class="view-count">{{ product.viewCount }}次浏览</span>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import { ROUTES } from '@/constants/routes'

const props = defineProps({
  product: {
    type: Object,
    required: true
  },
  clickable: {
    type: Boolean,
    default: true
  }
})

const router = useRouter()

const handleClick = () => {
  if (props.clickable) {
    router.push(ROUTES.PRODUCT_DETAIL(props.product.id))
  }
}
</script>
```

### 2. 组合式函数 (Composables)
```javascript
// src/composables/useProduct.js
import { ref, computed } from 'vue'
import { ElMessage } from 'element-plus'
import { productApi } from '@/api/product'

export function useProduct() {
  const loading = ref(false)
  const products = ref([])
  const total = ref(0)
  
  // 获取商品列表
  const fetchProducts = async (params = {}) => {
    loading.value = true
    try {
      const response = await productApi.getProducts(params)
      products.value = response.data.records
      total.value = response.data.total
    } catch (error) {
      ElMessage.error('获取商品列表失败')
      console.error('Fetch products error:', error)
    } finally {
      loading.value = false
    }
  }
  
  // 删除商品
  const deleteProduct = async (id) => {
    try {
      await productApi.deleteProduct(id)
      ElMessage.success('删除成功')
      // 从列表中移除
      const index = products.value.findIndex(p => p.id === id)
      if (index > -1) {
        products.value.splice(index, 1)
      }
    } catch (error) {
      ElMessage.error('删除失败')
      console.error('Delete product error:', error)
    }
  }
  
  // 计算属性
  const hasProducts = computed(() => products.value.length > 0)
  
  return {
    loading,
    products,
    total,
    hasProducts,
    fetchProducts,
    deleteProduct
  }
}
```

```javascript
// src/composables/useImageUpload.js
import { ref } from 'vue'
import { ElMessage } from 'element-plus'

export function useImageUpload(options = {}) {
  const {
    maxCount = 10,
    maxSize = 5 * 1024 * 1024, // 5MB
    allowedTypes = ['image/jpeg', 'image/png', 'image/gif']
  } = options
  
  const images = ref([])
  const uploading = ref(false)
  
  // 验证文件
  const validateFile = (file) => {
    if (!allowedTypes.includes(file.type)) {
      ElMessage.error('只支持 JPG、PNG、GIF 格式的图片')
      return false
    }
    
    if (file.size > maxSize) {
      ElMessage.error(`图片大小不能超过 ${maxSize / 1024 / 1024}MB`)
      return false
    }
    
    if (images.value.length >= maxCount) {
      ElMessage.error(`最多只能上传 ${maxCount} 张图片`)
      return false
    }
    
    return true
  }
  
  // 转换为 base64
  const fileToBase64 = (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = () => resolve(reader.result)
      reader.onerror = reject
      reader.readAsDataURL(file)
    })
  }
  
  // 上传图片
  const uploadImage = async (file) => {
    if (!validateFile(file)) return false
    
    uploading.value = true
    try {
      const base64 = await fileToBase64(file)
      images.value.push(base64)
      ElMessage.success('图片上传成功')
      return true
    } catch (error) {
      ElMessage.error('图片上传失败')
      console.error('Upload error:', error)
      return false
    } finally {
      uploading.value = false
    }
  }
  
  // 移除图片
  const removeImage = (index) => {
    images.value.splice(index, 1)
  }
  
  // 清空图片
  const clearImages = () => {
    images.value = []
  }
  
  return {
    images,
    uploading,
    uploadImage,
    removeImage,
    clearImages
  }
}
```

## 状态管理优化

### 1. Pinia Store 模块化
```javascript
// src/stores/modules/product.js
import { defineStore } from 'pinia'
import { productApi } from '@/api/product'

export const useProductStore = defineStore('product', {
  state: () => ({
    products: [],
    currentProduct: null,
    categories: [],
    filters: {
      keyword: '',
      categoryId: null,
      priceRange: [0, 10000],
      condition: null,
      sortBy: 'createdAt'
    },
    pagination: {
      current: 1,
      size: 20,
      total: 0
    }
  }),
  
  getters: {
    filteredProducts: (state) => {
      return state.products.filter(product => {
        // 应用过滤逻辑
        if (state.filters.keyword && 
            !product.title.includes(state.filters.keyword)) {
          return false
        }
        if (state.filters.categoryId && 
            product.categoryId !== state.filters.categoryId) {
          return false
        }
        return true
      })
    },
    
    productById: (state) => {
      return (id) => state.products.find(p => p.id === id)
    }
  },
  
  actions: {
    async fetchProducts(params = {}) {
      try {
        const response = await productApi.getProducts({
          ...this.filters,
          ...this.pagination,
          ...params
        })
        
        this.products = response.data.records
        this.pagination.total = response.data.total
      } catch (error) {
        console.error('Fetch products error:', error)
        throw error
      }
    },
    
    async fetchProductDetail(id) {
      try {
        const response = await productApi.getProductDetail(id)
        this.currentProduct = response.data
        return response.data
      } catch (error) {
        console.error('Fetch product detail error:', error)
        throw error
      }
    },
    
    updateFilters(newFilters) {
      this.filters = { ...this.filters, ...newFilters }
      this.pagination.current = 1 // 重置页码
    },
    
    resetFilters() {
      this.filters = {
        keyword: '',
        categoryId: null,
        priceRange: [0, 10000],
        condition: null,
        sortBy: 'createdAt'
      }
      this.pagination.current = 1
    }
  }
})
```

### 2. 持久化存储
```javascript
// src/stores/modules/user.js
import { defineStore } from 'pinia'
import { userApi } from '@/api/user'

export const useUserStore = defineStore('user', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null'),
    preferences: {
      theme: 'light',
      language: 'zh-CN',
      notifications: {
        email: true,
        push: true,
        sms: false
      }
    }
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.token,
    isAdmin: (state) => state.userInfo?.role === 'admin',
    isVerified: (state) => state.userInfo?.isVerified === true
  },
  
  actions: {
    setToken(token) {
      this.token = token
      localStorage.setItem('token', token)
    },
    
    setUserInfo(userInfo) {
      this.userInfo = userInfo
      localStorage.setItem('userInfo', JSON.stringify(userInfo))
    },
    
    logout() {
      this.token = ''
      this.userInfo = null
      localStorage.removeItem('token')
      localStorage.removeItem('userInfo')
    },
    
    updatePreferences(newPreferences) {
      this.preferences = { ...this.preferences, ...newPreferences }
      localStorage.setItem('userPreferences', JSON.stringify(this.preferences))
    }
  }
})
```

## API 管理优化

### 1. 统一的 API 客户端
```javascript
// src/utils/request.js
import axios from 'axios'
import { ElMessage, ElLoading } from 'element-plus'
import { useUserStore } from '@/stores/user'
import router from '@/router'

// 创建 axios 实例
const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    const userStore = useUserStore()
    
    // 添加认证头
    if (userStore.token) {
      config.headers.Authorization = `Bearer ${userStore.token}`
    }
    
    // 显示加载状态
    if (config.showLoading !== false) {
      config.loadingInstance = ElLoading.service({
        text: '加载中...',
        background: 'rgba(0, 0, 0, 0.7)'
      })
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    // 关闭加载状态
    if (response.config.loadingInstance) {
      response.config.loadingInstance.close()
    }
    
    const { code, message, data } = response.data
    
    if (code === 200) {
      return { data, message }
    } else {
      ElMessage.error(message || '请求失败')
      return Promise.reject(new Error(message || '请求失败'))
    }
  },
  (error) => {
    // 关闭加载状态
    if (error.config?.loadingInstance) {
      error.config.loadingInstance.close()
    }
    
    const { response } = error
    
    if (response?.status === 401) {
      ElMessage.error('登录已过期，请重新登录')
      const userStore = useUserStore()
      userStore.logout()
      router.push('/auth/login')
    } else if (response?.status === 403) {
      ElMessage.error('权限不足')
    } else if (response?.status >= 500) {
      ElMessage.error('服务器错误，请稍后重试')
    } else {
      ElMessage.error(error.message || '网络错误')
    }
    
    return Promise.reject(error)
  }
)

export default request
```

### 2. API 模块化管理
```javascript
// src/api/modules/product.js
import request from '@/utils/request'

export const productApi = {
  // 获取商品列表
  getProducts(params) {
    return request({
      url: '/products',
      method: 'GET',
      params
    })
  },
  
  // 获取商品详情
  getProductDetail(id) {
    return request({
      url: `/products/${id}`,
      method: 'GET'
    })
  },
  
  // 创建商品
  createProduct(data) {
    return request({
      url: '/products',
      method: 'POST',
      data
    })
  },
  
  // 更新商品
  updateProduct(id, data) {
    return request({
      url: `/products/${id}`,
      method: 'PUT',
      data
    })
  },
  
  // 删除商品
  deleteProduct(id) {
    return request({
      url: `/products/${id}`,
      method: 'DELETE'
    })
  },
  
  // 获取我的商品
  getMyProducts(params) {
    return request({
      url: '/products/my',
      method: 'GET',
      params
    })
  }
}
```

## 性能优化

### 1. 组件懒加载
```javascript
// src/utils/lazyLoad.js
import { defineAsyncComponent } from 'vue'
import LoadingComponent from '@/components/common/Loading.vue'
import ErrorComponent from '@/components/common/Error.vue'

export function lazyLoad(loader) {
  return defineAsyncComponent({
    loader,
    loadingComponent: LoadingComponent,
    errorComponent: ErrorComponent,
    delay: 200,
    timeout: 3000
  })
}
```

### 2. 图片懒加载和优化
```javascript
// src/directives/lazyLoad.js
export const lazyLoad = {
  mounted(el, binding) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target
          img.src = binding.value
          img.classList.remove('lazy')
          observer.unobserve(img)
        }
      })
    })
    
    el.classList.add('lazy')
    observer.observe(el)
  }
}
```

### 3. 虚拟滚动
```vue
<!-- src/components/common/VirtualList.vue -->
<template>
  <div class="virtual-list" ref="containerRef" @scroll="handleScroll">
    <div class="virtual-list-phantom" :style="{ height: totalHeight + 'px' }"></div>
    <div class="virtual-list-content" :style="contentStyle">
      <div
        v-for="item in visibleItems"
        :key="item.id"
        class="virtual-list-item"
        :style="{ height: itemHeight + 'px' }"
      >
        <slot :item="item" :index="item.index"></slot>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue'

const props = defineProps({
  items: {
    type: Array,
    required: true
  },
  itemHeight: {
    type: Number,
    default: 100
  },
  containerHeight: {
    type: Number,
    default: 400
  }
})

const containerRef = ref(null)
const scrollTop = ref(0)

const totalHeight = computed(() => props.items.length * props.itemHeight)
const visibleCount = computed(() => Math.ceil(props.containerHeight / props.itemHeight))
const startIndex = computed(() => Math.floor(scrollTop.value / props.itemHeight))
const endIndex = computed(() => Math.min(startIndex.value + visibleCount.value, props.items.length))

const visibleItems = computed(() => {
  return props.items.slice(startIndex.value, endIndex.value).map((item, index) => ({
    ...item,
    index: startIndex.value + index
  }))
})

const contentStyle = computed(() => ({
  transform: `translateY(${startIndex.value * props.itemHeight}px)`
}))

const handleScroll = (e) => {
  scrollTop.value = e.target.scrollTop
}
</script>
```

## 错误处理和监控

### 1. 全局错误处理
```javascript
// src/utils/errorHandler.js
import { ElMessage } from 'element-plus'

export function setupErrorHandler(app) {
  // Vue 错误处理
  app.config.errorHandler = (error, instance, info) => {
    console.error('Vue Error:', error, info)
    
    // 发送错误报告
    if (process.env.NODE_ENV === 'production') {
      reportError(error, { context: 'vue', info })
    }
    
    ElMessage.error('应用出现错误，请刷新页面重试')
  }
  
  // 全局未捕获的 Promise 错误
  window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled Promise Rejection:', event.reason)
    
    if (process.env.NODE_ENV === 'production') {
      reportError(event.reason, { context: 'promise' })
    }
    
    event.preventDefault()
  })
}

function reportError(error, context = {}) {
  // 发送错误报告到监控服务
  // 例如：Sentry, LogRocket 等
}
```

### 2. 用户行为追踪
```javascript
// src/utils/analytics.js
class Analytics {
  constructor() {
    this.enabled = process.env.NODE_ENV === 'production'
  }
  
  track(event, properties = {}) {
    if (!this.enabled) return
    
    // 发送到分析服务
    console.log('Analytics:', event, properties)
  }
  
  page(path, title) {
    this.track('page_view', { path, title })
  }
  
  user(userId, properties = {}) {
    this.track('user_identify', { userId, ...properties })
  }
}

export const analytics = new Analytics()
```

## 总结

这些改进建议涵盖了：

1. **路由管理**: 常量化路由、增强导航守卫
2. **组件架构**: 组件拆分、组合式函数、复用性提升
3. **状态管理**: Pinia 模块化、持久化存储
4. **API 管理**: 统一请求客户端、模块化 API
5. **性能优化**: 懒加载、虚拟滚动、图片优化
6. **错误处理**: 全局错误处理、用户行为追踪

实施这些改进将显著提升代码质量、可维护性和用户体验。